// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package vfmt_test

import (
	"github.com/nelsam/gxui"
	"github.com/nelsam/gxui/math"
	"github.com/nelsam/vidar/commander/text"
	"github.com/nelsam/vidar/setting"
)

type mockProjecter struct {
	ProjectCalled chan bool
	ProjectOutput struct {
		Ret0 chan setting.Project
	}
}

func newMockProjecter() *mockProjecter {
	m := &mockProjecter{}
	m.ProjectCalled = make(chan bool, 100)
	m.ProjectOutput.Ret0 = make(chan setting.Project, 100)
	return m
}
func (m *mockProjecter) Project() setting.Project {
	m.ProjectCalled <- true
	return <-m.ProjectOutput.Ret0
}

type mockApplier struct {
	ApplyCalled chan bool
	ApplyInput  struct {
		Arg0 chan text.Editor
		Arg1 chan []text.Edit
	}
}

func newMockApplier() *mockApplier {
	m := &mockApplier{}
	m.ApplyCalled = make(chan bool, 100)
	m.ApplyInput.Arg0 = make(chan text.Editor, 100)
	m.ApplyInput.Arg1 = make(chan []text.Edit, 100)
	return m
}
func (m *mockApplier) Apply(arg0 text.Editor, arg1 ...text.Edit) {
	m.ApplyCalled <- true
	m.ApplyInput.Arg0 <- arg0
	m.ApplyInput.Arg1 <- arg1
}

type mockLabelCreator struct {
	CreateLabelCalled chan bool
	CreateLabelOutput struct {
		Ret0 chan gxui.Label
	}
}

func newMockLabelCreator() *mockLabelCreator {
	m := &mockLabelCreator{}
	m.CreateLabelCalled = make(chan bool, 100)
	m.CreateLabelOutput.Ret0 = make(chan gxui.Label, 100)
	return m
}
func (m *mockLabelCreator) CreateLabel() gxui.Label {
	m.CreateLabelCalled <- true
	return <-m.CreateLabelOutput.Ret0
}

type mockEditor struct {
	FilepathCalled chan bool
	FilepathOutput struct {
		Ret0 chan string
	}
	TextCalled chan bool
	TextOutput struct {
		Ret0 chan string
	}
	RunesCalled chan bool
	RunesOutput struct {
		Ret0 chan []rune
	}
	SetTextCalled chan bool
	SetTextInput  struct {
		Arg0 chan string
	}
	SyntaxLayersCalled chan bool
	SyntaxLayersOutput struct {
		Ret0 chan []text.SyntaxLayer
	}
	SetSyntaxLayersCalled chan bool
	SetSyntaxLayersInput  struct {
		Arg0 chan []text.SyntaxLayer
	}
}

func newMockEditor() *mockEditor {
	m := &mockEditor{}
	m.FilepathCalled = make(chan bool, 100)
	m.FilepathOutput.Ret0 = make(chan string, 100)
	m.TextCalled = make(chan bool, 100)
	m.TextOutput.Ret0 = make(chan string, 100)
	m.RunesCalled = make(chan bool, 100)
	m.RunesOutput.Ret0 = make(chan []rune, 100)
	m.SetTextCalled = make(chan bool, 100)
	m.SetTextInput.Arg0 = make(chan string, 100)
	m.SyntaxLayersCalled = make(chan bool, 100)
	m.SyntaxLayersOutput.Ret0 = make(chan []text.SyntaxLayer, 100)
	m.SetSyntaxLayersCalled = make(chan bool, 100)
	m.SetSyntaxLayersInput.Arg0 = make(chan []text.SyntaxLayer, 100)
	return m
}
func (m *mockEditor) Filepath() string {
	m.FilepathCalled <- true
	return <-m.FilepathOutput.Ret0
}
func (m *mockEditor) Text() string {
	m.TextCalled <- true
	return <-m.TextOutput.Ret0
}
func (m *mockEditor) Runes() []rune {
	m.RunesCalled <- true
	return <-m.RunesOutput.Ret0
}
func (m *mockEditor) SetText(arg0 string) {
	m.SetTextCalled <- true
	m.SetTextInput.Arg0 <- arg0
}
func (m *mockEditor) SyntaxLayers() []text.SyntaxLayer {
	m.SyntaxLayersCalled <- true
	return <-m.SyntaxLayersOutput.Ret0
}
func (m *mockEditor) SetSyntaxLayers(arg0 []text.SyntaxLayer) {
	m.SetSyntaxLayersCalled <- true
	m.SetSyntaxLayersInput.Arg0 <- arg0
}

type mockLabel struct {
	SizeCalled chan bool
	SizeOutput struct {
		Ret0 chan math.Size
	}
	SetSizeCalled chan bool
	SetSizeInput  struct {
		Arg0 chan math.Size
	}
	DrawCalled chan bool
	DrawOutput struct {
		Ret0 chan gxui.Canvas
	}
	ParentCalled chan bool
	ParentOutput struct {
		Ret0 chan gxui.Parent
	}
	SetParentCalled chan bool
	SetParentInput  struct {
		Arg0 chan gxui.Parent
	}
	AttachedCalled chan bool
	AttachedOutput struct {
		Ret0 chan bool
	}
	AttachCalled      chan bool
	DetachCalled      chan bool
	DesiredSizeCalled chan bool
	DesiredSizeInput  struct {
		Min, Max chan math.Size
	}
	DesiredSizeOutput struct {
		Ret0 chan math.Size
	}
	MarginCalled chan bool
	MarginOutput struct {
		Ret0 chan math.Spacing
	}
	SetMarginCalled chan bool
	SetMarginInput  struct {
		Arg0 chan math.Spacing
	}
	IsVisibleCalled chan bool
	IsVisibleOutput struct {
		Ret0 chan bool
	}
	SetVisibleCalled chan bool
	SetVisibleInput  struct {
		Arg0 chan bool
	}
	ContainsPointCalled chan bool
	ContainsPointInput  struct {
		Arg0 chan math.Point
	}
	ContainsPointOutput struct {
		Ret0 chan bool
	}
	IsMouseOverCalled chan bool
	IsMouseOverOutput struct {
		Ret0 chan bool
	}
	IsMouseDownCalled chan bool
	IsMouseDownInput  struct {
		Button chan gxui.MouseButton
	}
	IsMouseDownOutput struct {
		Ret0 chan bool
	}
	ClickCalled chan bool
	ClickInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	ClickOutput struct {
		Consume chan bool
	}
	DoubleClickCalled chan bool
	DoubleClickInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	DoubleClickOutput struct {
		Consume chan bool
	}
	KeyPressCalled chan bool
	KeyPressInput  struct {
		Arg0 chan gxui.KeyboardEvent
	}
	KeyPressOutput struct {
		Consume chan bool
	}
	KeyStrokeCalled chan bool
	KeyStrokeInput  struct {
		Arg0 chan gxui.KeyStrokeEvent
	}
	KeyStrokeOutput struct {
		Consume chan bool
	}
	MouseScrollCalled chan bool
	MouseScrollInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	MouseScrollOutput struct {
		Consume chan bool
	}
	MouseMoveCalled chan bool
	MouseMoveInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	MouseEnterCalled chan bool
	MouseEnterInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	MouseExitCalled chan bool
	MouseExitInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	MouseDownCalled chan bool
	MouseDownInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	MouseUpCalled chan bool
	MouseUpInput  struct {
		Arg0 chan gxui.MouseEvent
	}
	KeyDownCalled chan bool
	KeyDownInput  struct {
		Arg0 chan gxui.KeyboardEvent
	}
	KeyUpCalled chan bool
	KeyUpInput  struct {
		Arg0 chan gxui.KeyboardEvent
	}
	KeyRepeatCalled chan bool
	KeyRepeatInput  struct {
		Arg0 chan gxui.KeyboardEvent
	}
	OnAttachCalled chan bool
	OnAttachInput  struct {
		F chan func()
	}
	OnAttachOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnDetachCalled chan bool
	OnDetachInput  struct {
		F chan func()
	}
	OnDetachOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnKeyPressCalled chan bool
	OnKeyPressInput  struct {
		F chan func(gxui.KeyboardEvent)
	}
	OnKeyPressOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnKeyStrokeCalled chan bool
	OnKeyStrokeInput  struct {
		F chan func(gxui.KeyStrokeEvent)
	}
	OnKeyStrokeOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnClickCalled chan bool
	OnClickInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnClickOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnDoubleClickCalled chan bool
	OnDoubleClickInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnDoubleClickOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseMoveCalled chan bool
	OnMouseMoveInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseMoveOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseEnterCalled chan bool
	OnMouseEnterInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseEnterOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseExitCalled chan bool
	OnMouseExitInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseExitOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseDownCalled chan bool
	OnMouseDownInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseDownOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseUpCalled chan bool
	OnMouseUpInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseUpOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnMouseScrollCalled chan bool
	OnMouseScrollInput  struct {
		F chan func(gxui.MouseEvent)
	}
	OnMouseScrollOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnKeyDownCalled chan bool
	OnKeyDownInput  struct {
		F chan func(gxui.KeyboardEvent)
	}
	OnKeyDownOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnKeyUpCalled chan bool
	OnKeyUpInput  struct {
		F chan func(gxui.KeyboardEvent)
	}
	OnKeyUpOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	OnKeyRepeatCalled chan bool
	OnKeyRepeatInput  struct {
		F chan func(gxui.KeyboardEvent)
	}
	OnKeyRepeatOutput struct {
		Ret0 chan gxui.EventSubscription
	}
	TextCalled chan bool
	TextOutput struct {
		Ret0 chan string
	}
	SetTextCalled chan bool
	SetTextInput  struct {
		Arg0 chan string
	}
	FontCalled chan bool
	FontOutput struct {
		Ret0 chan gxui.Font
	}
	SetFontCalled chan bool
	SetFontInput  struct {
		Arg0 chan gxui.Font
	}
	ColorCalled chan bool
	ColorOutput struct {
		Ret0 chan gxui.Color
	}
	SetColorCalled chan bool
	SetColorInput  struct {
		Arg0 chan gxui.Color
	}
	MultilineCalled chan bool
	MultilineOutput struct {
		Ret0 chan bool
	}
	SetMultilineCalled chan bool
	SetMultilineInput  struct {
		Arg0 chan bool
	}
	SetHorizontalAlignmentCalled chan bool
	SetHorizontalAlignmentInput  struct {
		Arg0 chan gxui.HorizontalAlignment
	}
	HorizontalAlignmentCalled chan bool
	HorizontalAlignmentOutput struct {
		Ret0 chan gxui.HorizontalAlignment
	}
	SetVerticalAlignmentCalled chan bool
	SetVerticalAlignmentInput  struct {
		Arg0 chan gxui.VerticalAlignment
	}
	VerticalAlignmentCalled chan bool
	VerticalAlignmentOutput struct {
		Ret0 chan gxui.VerticalAlignment
	}
}

func newMockLabel() *mockLabel {
	m := &mockLabel{}
	m.SizeCalled = make(chan bool, 100)
	m.SizeOutput.Ret0 = make(chan math.Size, 100)
	m.SetSizeCalled = make(chan bool, 100)
	m.SetSizeInput.Arg0 = make(chan math.Size, 100)
	m.DrawCalled = make(chan bool, 100)
	m.DrawOutput.Ret0 = make(chan gxui.Canvas, 100)
	m.ParentCalled = make(chan bool, 100)
	m.ParentOutput.Ret0 = make(chan gxui.Parent, 100)
	m.SetParentCalled = make(chan bool, 100)
	m.SetParentInput.Arg0 = make(chan gxui.Parent, 100)
	m.AttachedCalled = make(chan bool, 100)
	m.AttachedOutput.Ret0 = make(chan bool, 100)
	m.AttachCalled = make(chan bool, 100)
	m.DetachCalled = make(chan bool, 100)
	m.DesiredSizeCalled = make(chan bool, 100)
	m.DesiredSizeInput.Min = make(chan math.Size, 100)
	m.DesiredSizeInput.Max = make(chan math.Size, 100)
	m.DesiredSizeOutput.Ret0 = make(chan math.Size, 100)
	m.MarginCalled = make(chan bool, 100)
	m.MarginOutput.Ret0 = make(chan math.Spacing, 100)
	m.SetMarginCalled = make(chan bool, 100)
	m.SetMarginInput.Arg0 = make(chan math.Spacing, 100)
	m.IsVisibleCalled = make(chan bool, 100)
	m.IsVisibleOutput.Ret0 = make(chan bool, 100)
	m.SetVisibleCalled = make(chan bool, 100)
	m.SetVisibleInput.Arg0 = make(chan bool, 100)
	m.ContainsPointCalled = make(chan bool, 100)
	m.ContainsPointInput.Arg0 = make(chan math.Point, 100)
	m.ContainsPointOutput.Ret0 = make(chan bool, 100)
	m.IsMouseOverCalled = make(chan bool, 100)
	m.IsMouseOverOutput.Ret0 = make(chan bool, 100)
	m.IsMouseDownCalled = make(chan bool, 100)
	m.IsMouseDownInput.Button = make(chan gxui.MouseButton, 100)
	m.IsMouseDownOutput.Ret0 = make(chan bool, 100)
	m.ClickCalled = make(chan bool, 100)
	m.ClickInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.ClickOutput.Consume = make(chan bool, 100)
	m.DoubleClickCalled = make(chan bool, 100)
	m.DoubleClickInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.DoubleClickOutput.Consume = make(chan bool, 100)
	m.KeyPressCalled = make(chan bool, 100)
	m.KeyPressInput.Arg0 = make(chan gxui.KeyboardEvent, 100)
	m.KeyPressOutput.Consume = make(chan bool, 100)
	m.KeyStrokeCalled = make(chan bool, 100)
	m.KeyStrokeInput.Arg0 = make(chan gxui.KeyStrokeEvent, 100)
	m.KeyStrokeOutput.Consume = make(chan bool, 100)
	m.MouseScrollCalled = make(chan bool, 100)
	m.MouseScrollInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.MouseScrollOutput.Consume = make(chan bool, 100)
	m.MouseMoveCalled = make(chan bool, 100)
	m.MouseMoveInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.MouseEnterCalled = make(chan bool, 100)
	m.MouseEnterInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.MouseExitCalled = make(chan bool, 100)
	m.MouseExitInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.MouseDownCalled = make(chan bool, 100)
	m.MouseDownInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.MouseUpCalled = make(chan bool, 100)
	m.MouseUpInput.Arg0 = make(chan gxui.MouseEvent, 100)
	m.KeyDownCalled = make(chan bool, 100)
	m.KeyDownInput.Arg0 = make(chan gxui.KeyboardEvent, 100)
	m.KeyUpCalled = make(chan bool, 100)
	m.KeyUpInput.Arg0 = make(chan gxui.KeyboardEvent, 100)
	m.KeyRepeatCalled = make(chan bool, 100)
	m.KeyRepeatInput.Arg0 = make(chan gxui.KeyboardEvent, 100)
	m.OnAttachCalled = make(chan bool, 100)
	m.OnAttachInput.F = make(chan func(), 100)
	m.OnAttachOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnDetachCalled = make(chan bool, 100)
	m.OnDetachInput.F = make(chan func(), 100)
	m.OnDetachOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnKeyPressCalled = make(chan bool, 100)
	m.OnKeyPressInput.F = make(chan func(gxui.KeyboardEvent), 100)
	m.OnKeyPressOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnKeyStrokeCalled = make(chan bool, 100)
	m.OnKeyStrokeInput.F = make(chan func(gxui.KeyStrokeEvent), 100)
	m.OnKeyStrokeOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnClickCalled = make(chan bool, 100)
	m.OnClickInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnClickOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnDoubleClickCalled = make(chan bool, 100)
	m.OnDoubleClickInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnDoubleClickOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseMoveCalled = make(chan bool, 100)
	m.OnMouseMoveInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseMoveOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseEnterCalled = make(chan bool, 100)
	m.OnMouseEnterInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseEnterOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseExitCalled = make(chan bool, 100)
	m.OnMouseExitInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseExitOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseDownCalled = make(chan bool, 100)
	m.OnMouseDownInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseDownOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseUpCalled = make(chan bool, 100)
	m.OnMouseUpInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseUpOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnMouseScrollCalled = make(chan bool, 100)
	m.OnMouseScrollInput.F = make(chan func(gxui.MouseEvent), 100)
	m.OnMouseScrollOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnKeyDownCalled = make(chan bool, 100)
	m.OnKeyDownInput.F = make(chan func(gxui.KeyboardEvent), 100)
	m.OnKeyDownOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnKeyUpCalled = make(chan bool, 100)
	m.OnKeyUpInput.F = make(chan func(gxui.KeyboardEvent), 100)
	m.OnKeyUpOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.OnKeyRepeatCalled = make(chan bool, 100)
	m.OnKeyRepeatInput.F = make(chan func(gxui.KeyboardEvent), 100)
	m.OnKeyRepeatOutput.Ret0 = make(chan gxui.EventSubscription, 100)
	m.TextCalled = make(chan bool, 100)
	m.TextOutput.Ret0 = make(chan string, 100)
	m.SetTextCalled = make(chan bool, 100)
	m.SetTextInput.Arg0 = make(chan string, 100)
	m.FontCalled = make(chan bool, 100)
	m.FontOutput.Ret0 = make(chan gxui.Font, 100)
	m.SetFontCalled = make(chan bool, 100)
	m.SetFontInput.Arg0 = make(chan gxui.Font, 100)
	m.ColorCalled = make(chan bool, 100)
	m.ColorOutput.Ret0 = make(chan gxui.Color, 100)
	m.SetColorCalled = make(chan bool, 100)
	m.SetColorInput.Arg0 = make(chan gxui.Color, 100)
	m.MultilineCalled = make(chan bool, 100)
	m.MultilineOutput.Ret0 = make(chan bool, 100)
	m.SetMultilineCalled = make(chan bool, 100)
	m.SetMultilineInput.Arg0 = make(chan bool, 100)
	m.SetHorizontalAlignmentCalled = make(chan bool, 100)
	m.SetHorizontalAlignmentInput.Arg0 = make(chan gxui.HorizontalAlignment, 100)
	m.HorizontalAlignmentCalled = make(chan bool, 100)
	m.HorizontalAlignmentOutput.Ret0 = make(chan gxui.HorizontalAlignment, 100)
	m.SetVerticalAlignmentCalled = make(chan bool, 100)
	m.SetVerticalAlignmentInput.Arg0 = make(chan gxui.VerticalAlignment, 100)
	m.VerticalAlignmentCalled = make(chan bool, 100)
	m.VerticalAlignmentOutput.Ret0 = make(chan gxui.VerticalAlignment, 100)
	return m
}
func (m *mockLabel) Size() math.Size {
	m.SizeCalled <- true
	return <-m.SizeOutput.Ret0
}
func (m *mockLabel) SetSize(arg0 math.Size) {
	m.SetSizeCalled <- true
	m.SetSizeInput.Arg0 <- arg0
}
func (m *mockLabel) Draw() gxui.Canvas {
	m.DrawCalled <- true
	return <-m.DrawOutput.Ret0
}
func (m *mockLabel) Parent() gxui.Parent {
	m.ParentCalled <- true
	return <-m.ParentOutput.Ret0
}
func (m *mockLabel) SetParent(arg0 gxui.Parent) {
	m.SetParentCalled <- true
	m.SetParentInput.Arg0 <- arg0
}
func (m *mockLabel) Attached() bool {
	m.AttachedCalled <- true
	return <-m.AttachedOutput.Ret0
}
func (m *mockLabel) Attach() {
	m.AttachCalled <- true
}
func (m *mockLabel) Detach() {
	m.DetachCalled <- true
}
func (m *mockLabel) DesiredSize(min, max math.Size) math.Size {
	m.DesiredSizeCalled <- true
	m.DesiredSizeInput.Min <- min
	m.DesiredSizeInput.Max <- max
	return <-m.DesiredSizeOutput.Ret0
}
func (m *mockLabel) Margin() math.Spacing {
	m.MarginCalled <- true
	return <-m.MarginOutput.Ret0
}
func (m *mockLabel) SetMargin(arg0 math.Spacing) {
	m.SetMarginCalled <- true
	m.SetMarginInput.Arg0 <- arg0
}
func (m *mockLabel) IsVisible() bool {
	m.IsVisibleCalled <- true
	return <-m.IsVisibleOutput.Ret0
}
func (m *mockLabel) SetVisible(arg0 bool) {
	m.SetVisibleCalled <- true
	m.SetVisibleInput.Arg0 <- arg0
}
func (m *mockLabel) ContainsPoint(arg0 math.Point) bool {
	m.ContainsPointCalled <- true
	m.ContainsPointInput.Arg0 <- arg0
	return <-m.ContainsPointOutput.Ret0
}
func (m *mockLabel) IsMouseOver() bool {
	m.IsMouseOverCalled <- true
	return <-m.IsMouseOverOutput.Ret0
}
func (m *mockLabel) IsMouseDown(button gxui.MouseButton) bool {
	m.IsMouseDownCalled <- true
	m.IsMouseDownInput.Button <- button
	return <-m.IsMouseDownOutput.Ret0
}
func (m *mockLabel) Click(arg0 gxui.MouseEvent) (consume bool) {
	m.ClickCalled <- true
	m.ClickInput.Arg0 <- arg0
	return <-m.ClickOutput.Consume
}
func (m *mockLabel) DoubleClick(arg0 gxui.MouseEvent) (consume bool) {
	m.DoubleClickCalled <- true
	m.DoubleClickInput.Arg0 <- arg0
	return <-m.DoubleClickOutput.Consume
}
func (m *mockLabel) KeyPress(arg0 gxui.KeyboardEvent) (consume bool) {
	m.KeyPressCalled <- true
	m.KeyPressInput.Arg0 <- arg0
	return <-m.KeyPressOutput.Consume
}
func (m *mockLabel) KeyStroke(arg0 gxui.KeyStrokeEvent) (consume bool) {
	m.KeyStrokeCalled <- true
	m.KeyStrokeInput.Arg0 <- arg0
	return <-m.KeyStrokeOutput.Consume
}
func (m *mockLabel) MouseScroll(arg0 gxui.MouseEvent) (consume bool) {
	m.MouseScrollCalled <- true
	m.MouseScrollInput.Arg0 <- arg0
	return <-m.MouseScrollOutput.Consume
}
func (m *mockLabel) MouseMove(arg0 gxui.MouseEvent) {
	m.MouseMoveCalled <- true
	m.MouseMoveInput.Arg0 <- arg0
}
func (m *mockLabel) MouseEnter(arg0 gxui.MouseEvent) {
	m.MouseEnterCalled <- true
	m.MouseEnterInput.Arg0 <- arg0
}
func (m *mockLabel) MouseExit(arg0 gxui.MouseEvent) {
	m.MouseExitCalled <- true
	m.MouseExitInput.Arg0 <- arg0
}
func (m *mockLabel) MouseDown(arg0 gxui.MouseEvent) {
	m.MouseDownCalled <- true
	m.MouseDownInput.Arg0 <- arg0
}
func (m *mockLabel) MouseUp(arg0 gxui.MouseEvent) {
	m.MouseUpCalled <- true
	m.MouseUpInput.Arg0 <- arg0
}
func (m *mockLabel) KeyDown(arg0 gxui.KeyboardEvent) {
	m.KeyDownCalled <- true
	m.KeyDownInput.Arg0 <- arg0
}
func (m *mockLabel) KeyUp(arg0 gxui.KeyboardEvent) {
	m.KeyUpCalled <- true
	m.KeyUpInput.Arg0 <- arg0
}
func (m *mockLabel) KeyRepeat(arg0 gxui.KeyboardEvent) {
	m.KeyRepeatCalled <- true
	m.KeyRepeatInput.Arg0 <- arg0
}
func (m *mockLabel) OnAttach(f func()) gxui.EventSubscription {
	m.OnAttachCalled <- true
	m.OnAttachInput.F <- f
	return <-m.OnAttachOutput.Ret0
}
func (m *mockLabel) OnDetach(f func()) gxui.EventSubscription {
	m.OnDetachCalled <- true
	m.OnDetachInput.F <- f
	return <-m.OnDetachOutput.Ret0
}
func (m *mockLabel) OnKeyPress(f func(gxui.KeyboardEvent)) gxui.EventSubscription {
	m.OnKeyPressCalled <- true
	m.OnKeyPressInput.F <- f
	return <-m.OnKeyPressOutput.Ret0
}
func (m *mockLabel) OnKeyStroke(f func(gxui.KeyStrokeEvent)) gxui.EventSubscription {
	m.OnKeyStrokeCalled <- true
	m.OnKeyStrokeInput.F <- f
	return <-m.OnKeyStrokeOutput.Ret0
}
func (m *mockLabel) OnClick(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnClickCalled <- true
	m.OnClickInput.F <- f
	return <-m.OnClickOutput.Ret0
}
func (m *mockLabel) OnDoubleClick(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnDoubleClickCalled <- true
	m.OnDoubleClickInput.F <- f
	return <-m.OnDoubleClickOutput.Ret0
}
func (m *mockLabel) OnMouseMove(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseMoveCalled <- true
	m.OnMouseMoveInput.F <- f
	return <-m.OnMouseMoveOutput.Ret0
}
func (m *mockLabel) OnMouseEnter(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseEnterCalled <- true
	m.OnMouseEnterInput.F <- f
	return <-m.OnMouseEnterOutput.Ret0
}
func (m *mockLabel) OnMouseExit(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseExitCalled <- true
	m.OnMouseExitInput.F <- f
	return <-m.OnMouseExitOutput.Ret0
}
func (m *mockLabel) OnMouseDown(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseDownCalled <- true
	m.OnMouseDownInput.F <- f
	return <-m.OnMouseDownOutput.Ret0
}
func (m *mockLabel) OnMouseUp(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseUpCalled <- true
	m.OnMouseUpInput.F <- f
	return <-m.OnMouseUpOutput.Ret0
}
func (m *mockLabel) OnMouseScroll(f func(gxui.MouseEvent)) gxui.EventSubscription {
	m.OnMouseScrollCalled <- true
	m.OnMouseScrollInput.F <- f
	return <-m.OnMouseScrollOutput.Ret0
}
func (m *mockLabel) OnKeyDown(f func(gxui.KeyboardEvent)) gxui.EventSubscription {
	m.OnKeyDownCalled <- true
	m.OnKeyDownInput.F <- f
	return <-m.OnKeyDownOutput.Ret0
}
func (m *mockLabel) OnKeyUp(f func(gxui.KeyboardEvent)) gxui.EventSubscription {
	m.OnKeyUpCalled <- true
	m.OnKeyUpInput.F <- f
	return <-m.OnKeyUpOutput.Ret0
}
func (m *mockLabel) OnKeyRepeat(f func(gxui.KeyboardEvent)) gxui.EventSubscription {
	m.OnKeyRepeatCalled <- true
	m.OnKeyRepeatInput.F <- f
	return <-m.OnKeyRepeatOutput.Ret0
}
func (m *mockLabel) Text() string {
	m.TextCalled <- true
	return <-m.TextOutput.Ret0
}
func (m *mockLabel) SetText(arg0 string) {
	m.SetTextCalled <- true
	m.SetTextInput.Arg0 <- arg0
}
func (m *mockLabel) Font() gxui.Font {
	m.FontCalled <- true
	return <-m.FontOutput.Ret0
}
func (m *mockLabel) SetFont(arg0 gxui.Font) {
	m.SetFontCalled <- true
	m.SetFontInput.Arg0 <- arg0
}
func (m *mockLabel) Color() gxui.Color {
	m.ColorCalled <- true
	return <-m.ColorOutput.Ret0
}
func (m *mockLabel) SetColor(arg0 gxui.Color) {
	m.SetColorCalled <- true
	m.SetColorInput.Arg0 <- arg0
}
func (m *mockLabel) Multiline() bool {
	m.MultilineCalled <- true
	return <-m.MultilineOutput.Ret0
}
func (m *mockLabel) SetMultiline(arg0 bool) {
	m.SetMultilineCalled <- true
	m.SetMultilineInput.Arg0 <- arg0
}
func (m *mockLabel) SetHorizontalAlignment(arg0 gxui.HorizontalAlignment) {
	m.SetHorizontalAlignmentCalled <- true
	m.SetHorizontalAlignmentInput.Arg0 <- arg0
}
func (m *mockLabel) HorizontalAlignment() gxui.HorizontalAlignment {
	m.HorizontalAlignmentCalled <- true
	return <-m.HorizontalAlignmentOutput.Ret0
}
func (m *mockLabel) SetVerticalAlignment(arg0 gxui.VerticalAlignment) {
	m.SetVerticalAlignmentCalled <- true
	m.SetVerticalAlignmentInput.Arg0 <- arg0
}
func (m *mockLabel) VerticalAlignment() gxui.VerticalAlignment {
	m.VerticalAlignmentCalled <- true
	return <-m.VerticalAlignmentOutput.Ret0
}
